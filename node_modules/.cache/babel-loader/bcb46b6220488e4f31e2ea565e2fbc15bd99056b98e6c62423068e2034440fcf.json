{"ast":null,"code":"import _slicedToArray from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\nvar DOMKeyframesResolver = /*#__PURE__*/function (_KeyframeResolver) {\n  _inherits(DOMKeyframesResolver, _KeyframeResolver);\n  var _super = _createSuper(DOMKeyframesResolver);\n  function DOMKeyframesResolver(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    _classCallCheck(this, DOMKeyframesResolver);\n    return _super.call(this, unresolvedKeyframes, onComplete, name, motionValue, element, true);\n  }\n  _createClass(DOMKeyframesResolver, [{\n    key: \"readKeyframes\",\n    value: function readKeyframes() {\n      var unresolvedKeyframes = this.unresolvedKeyframes,\n        element = this.element,\n        name = this.name;\n      if (!element || !element.current) return;\n      _get(_getPrototypeOf(DOMKeyframesResolver.prototype), \"readKeyframes\", this).call(this);\n      /**\n       * If any keyframe is a CSS variable, we need to find its value by sampling the element\n       */\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        var keyframe = unresolvedKeyframes[i];\n        if (typeof keyframe === \"string\") {\n          keyframe = keyframe.trim();\n          if (isCSSVariableToken(keyframe)) {\n            var resolved = getVariableValue(keyframe, element.current);\n            if (resolved !== undefined) {\n              unresolvedKeyframes[i] = resolved;\n            }\n            if (i === unresolvedKeyframes.length - 1) {\n              this.finalKeyframe = keyframe;\n            }\n          }\n        }\n      }\n      /**\n       * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n       * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n       * have a far bigger performance impact.\n       */\n      this.resolveNoneKeyframes();\n      /**\n       * Check to see if unit type has changed. If so schedule jobs that will\n       * temporarily set styles to the destination keyframes.\n       * Skip if we have more than two keyframes or this isn't a positional value.\n       * TODO: We can throw if there are multiple keyframes and the value type changes.\n       */\n      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n        return;\n      }\n      var _unresolvedKeyframes = _slicedToArray(unresolvedKeyframes, 2),\n        origin = _unresolvedKeyframes[0],\n        target = _unresolvedKeyframes[1];\n      var originType = findDimensionValueType(origin);\n      var targetType = findDimensionValueType(target);\n      /**\n       * Either we don't recognise these value types or we can animate between them.\n       */\n      if (originType === targetType) return;\n      /**\n       * If both values are numbers or pixels, we can animate between them by\n       * converting them to numbers.\n       */\n      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n        for (var _i = 0; _i < unresolvedKeyframes.length; _i++) {\n          var value = unresolvedKeyframes[_i];\n          if (typeof value === \"string\") {\n            unresolvedKeyframes[_i] = parseFloat(value);\n          }\n        }\n      } else {\n        /**\n         * Else, the only way to resolve this is by measuring the element.\n         */\n        this.needsMeasurement = true;\n      }\n    }\n  }, {\n    key: \"resolveNoneKeyframes\",\n    value: function resolveNoneKeyframes() {\n      var unresolvedKeyframes = this.unresolvedKeyframes,\n        name = this.name;\n      var noneKeyframeIndexes = [];\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        if (isNone(unresolvedKeyframes[i])) {\n          noneKeyframeIndexes.push(i);\n        }\n      }\n      if (noneKeyframeIndexes.length) {\n        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n      }\n    }\n  }, {\n    key: \"measureInitialState\",\n    value: function measureInitialState() {\n      var element = this.element,\n        unresolvedKeyframes = this.unresolvedKeyframes,\n        name = this.name;\n      if (!element || !element.current) return;\n      if (name === \"height\") {\n        this.suspendedScrollY = window.pageYOffset;\n      }\n      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n      unresolvedKeyframes[0] = this.measuredOrigin;\n      // Set final key frame to measure after next render\n      var measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n      if (measureKeyframe !== undefined) {\n        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n      }\n    }\n  }, {\n    key: \"measureEndState\",\n    value: function measureEndState() {\n      var _a;\n      var element = this.element,\n        name = this.name,\n        unresolvedKeyframes = this.unresolvedKeyframes;\n      if (!element || !element.current) return;\n      var value = element.getValue(name);\n      value && value.jump(this.measuredOrigin, false);\n      var finalKeyframeIndex = unresolvedKeyframes.length - 1;\n      var finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n      if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n        this.finalKeyframe = finalKeyframe;\n      }\n      // If we removed transform values, reapply them before the next render\n      if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n        this.removedTransforms.forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            unsetTransformName = _ref2[0],\n            unsetTransformValue = _ref2[1];\n          element.getValue(unsetTransformName).set(unsetTransformValue);\n        });\n      }\n      this.resolveNoneKeyframes();\n    }\n  }]);\n  return DOMKeyframesResolver;\n}(KeyframeResolver);\nexport { DOMKeyframesResolver };","map":{"version":3,"names":["isNone","getVariableValue","isCSSVariableToken","positionalKeys","isNumOrPxType","positionalValues","findDimensionValueType","KeyframeResolver","makeNoneKeyframesAnimatable","DOMKeyframesResolver","_KeyframeResolver","_inherits","_super","_createSuper","unresolvedKeyframes","onComplete","name","motionValue","element","_classCallCheck","call","_createClass","key","value","readKeyframes","current","_get","_getPrototypeOf","prototype","i","length","keyframe","trim","resolved","undefined","finalKeyframe","resolveNoneKeyframes","has","_unresolvedKeyframes","_slicedToArray","origin","target","originType","targetType","parseFloat","needsMeasurement","noneKeyframeIndexes","push","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","_a","finalKeyframeIndex","removedTransforms","forEach","_ref","_ref2","unsetTransformName","unsetTransformValue","set"],"sources":["/Users/Ksquare/Documents/Software/home/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs"],"sourcesContent":["import { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}