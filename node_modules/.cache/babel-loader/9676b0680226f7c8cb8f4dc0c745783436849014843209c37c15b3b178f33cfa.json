{"ast":null,"code":"import _objectWithoutProperties from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"onComplete\", \"onUpdate\", \"motionValue\", \"element\"],\n  _excluded2 = [\"motionValue\", \"onUpdate\", \"onComplete\", \"element\"];\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nvar supportsWaapi = /*@__PURE__*/memo(function () {\n  return Object.hasOwnProperty.call(Element.prototype, \"animate\");\n});\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nvar sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nvar maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n  return options.type === \"spring\" || !isWaapiSupportedEasing(options.ease);\n}\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n    keyframes: keyframes,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  }));\n  var state = {\n    done: false,\n    value: keyframes[0]\n  };\n  var pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n  var t = 0;\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\nvar AcceleratedAnimation = /*#__PURE__*/function (_BaseAnimation) {\n  _inherits(AcceleratedAnimation, _BaseAnimation);\n  var _super = _createSuper(AcceleratedAnimation);\n  function AcceleratedAnimation(options) {\n    var _this;\n    _classCallCheck(this, AcceleratedAnimation);\n    _this = _super.call(this, options);\n    var _this$options = _this.options,\n      name = _this$options.name,\n      motionValue = _this$options.motionValue,\n      element = _this$options.element,\n      keyframes = _this$options.keyframes;\n    _this.resolver = new DOMKeyframesResolver(keyframes, function (resolvedKeyframes, finalKeyframe) {\n      return _this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    }, name, motionValue, element);\n    _this.resolver.scheduleResolve();\n    return _this;\n  }\n  _createClass(AcceleratedAnimation, [{\n    key: \"initPlayback\",\n    value: function initPlayback(keyframes, finalKeyframe) {\n      var _this2 = this;\n      var _a;\n      var _this$options2 = this.options,\n        _this$options2$durati = _this$options2.duration,\n        duration = _this$options2$durati === void 0 ? 300 : _this$options2$durati,\n        times = _this$options2.times,\n        ease = _this$options2.ease,\n        type = _this$options2.type,\n        motionValue = _this$options2.motionValue,\n        name = _this$options2.name,\n        startTime = _this$options2.startTime;\n      /**\n       * If element has since been unmounted, return false to indicate\n       * the animation failed to initialised.\n       */\n      if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n        return false;\n      }\n      /**\n       * If this animation needs pre-generated keyframes then generate.\n       */\n      if (requiresPregeneratedKeyframes(this.options)) {\n        var _this$options3 = this.options,\n          onComplete = _this$options3.onComplete,\n          onUpdate = _this$options3.onUpdate,\n          _motionValue = _this$options3.motionValue,\n          element = _this$options3.element,\n          options = _objectWithoutProperties(_this$options3, _excluded);\n        var pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n        keyframes = pregeneratedAnimation.keyframes;\n        // If this is a very short animation, ensure we have\n        // at least two keyframes to animate between as older browsers\n        // can't animate between a single keyframe.\n        if (keyframes.length === 1) {\n          keyframes[1] = keyframes[0];\n        }\n        duration = pregeneratedAnimation.duration;\n        times = pregeneratedAnimation.times;\n        ease = pregeneratedAnimation.ease;\n        type = \"keyframes\";\n      }\n      var animation = animateStyle(motionValue.owner.current, name, keyframes, _objectSpread(_objectSpread({}, this.options), {}, {\n        duration: duration,\n        times: times,\n        ease: ease\n      }));\n      // Override the browser calculated startTime with one synchronised to other JS\n      // and WAAPI animations starting this event loop.\n      animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n      if (this.pendingTimeline) {\n        animation.timeline = this.pendingTimeline;\n        this.pendingTimeline = undefined;\n      } else {\n        /**\n         * Prefer the `onfinish` prop as it's more widely supported than\n         * the `finished` promise.\n         *\n         * Here, we synchronously set the provided MotionValue to the end\n         * keyframe. If we didn't, when the WAAPI animation is finished it would\n         * be removed from the element which would then revert to its old styles.\n         */\n        animation.onfinish = function () {\n          var onComplete = _this2.options.onComplete;\n          motionValue.set(getFinalKeyframe(keyframes, _this2.options, finalKeyframe));\n          onComplete && onComplete();\n          _this2.cancel();\n          _this2.resolveFinishedPromise();\n        };\n      }\n      return {\n        animation: animation,\n        duration: duration,\n        times: times,\n        type: type,\n        ease: ease,\n        keyframes: keyframes\n      };\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var duration = resolved.duration;\n      return millisecondsToSeconds(duration);\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var animation = resolved.animation;\n      return millisecondsToSeconds(animation.currentTime || 0);\n    },\n    set: function set(newTime) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.currentTime = secondsToMilliseconds(newTime);\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 1;\n      var animation = resolved.animation;\n      return animation.playbackRate;\n    },\n    set: function set(newSpeed) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.playbackRate = newSpeed;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return \"idle\";\n      var animation = resolved.animation;\n      return animation.playState;\n    }\n  }, {\n    key: \"startTime\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return null;\n      var animation = resolved.animation;\n      // Coerce to number as TypeScript incorrectly types this\n      // as CSSNumberish\n      return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n  }, {\n    key: \"attachTimeline\",\n    value: function attachTimeline(timeline) {\n      if (!this._resolved) {\n        this.pendingTimeline = timeline;\n      } else {\n        var resolved = this.resolved;\n        if (!resolved) return noop;\n        var animation = resolved.animation;\n        animation.timeline = timeline;\n        animation.onfinish = null;\n      }\n      return noop;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.isStopped) return;\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      if (animation.playState === \"finished\") {\n        this.updateFinishedPromise();\n      }\n      animation.play();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.pause();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.resolver.cancel();\n      this.isStopped = true;\n      if (this.state === \"idle\") return;\n      this.resolveFinishedPromise();\n      this.updateFinishedPromise();\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation,\n        keyframes = resolved.keyframes,\n        duration = resolved.duration,\n        type = resolved.type,\n        ease = resolved.ease,\n        times = resolved.times;\n      if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n        return;\n      }\n      /**\n       * WAAPI doesn't natively have any interruption capabilities.\n       *\n       * Rather than read commited styles back out of the DOM, we can\n       * create a renderless JS animation and sample it twice to calculate\n       * its current value, \"previous\" value, and therefore allow\n       * Motion to calculate velocity for any subsequent animation.\n       */\n      if (this.time) {\n        var _this$options4 = this.options,\n          motionValue = _this$options4.motionValue,\n          onUpdate = _this$options4.onUpdate,\n          onComplete = _this$options4.onComplete,\n          element = _this$options4.element,\n          options = _objectWithoutProperties(_this$options4, _excluded2);\n        var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n          keyframes: keyframes,\n          duration: duration,\n          type: type,\n          ease: ease,\n          times: times,\n          isGenerator: true\n        }));\n        var sampleTime = secondsToMilliseconds(this.time);\n        motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n      }\n      var onStop = this.options.onStop;\n      onStop && onStop();\n      this.cancel();\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.finish();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.cancel();\n    }\n  }], [{\n    key: \"supports\",\n    value: function supports(options) {\n      var motionValue = options.motionValue,\n        name = options.name,\n        repeatDelay = options.repeatDelay,\n        repeatType = options.repeatType,\n        damping = options.damping,\n        type = options.type;\n      return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement &&\n      /**\n       * If we're outputting values to onUpdate then we can't use WAAPI as there's\n       * no way to read the value from WAAPI every frame.\n       */\n      !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n    }\n  }]);\n  return AcceleratedAnimation;\n}(BaseAnimation);\nexport { AcceleratedAnimation };","map":{"version":3,"names":["DOMKeyframesResolver","memo","noop","millisecondsToSeconds","secondsToMilliseconds","BaseAnimation","MainThreadAnimation","acceleratedValues","animateStyle","isWaapiSupportedEasing","getFinalKeyframe","supportsWaapi","Object","hasOwnProperty","call","Element","prototype","sampleDelta","maxDuration","requiresPregeneratedKeyframes","options","type","ease","pregenerateKeyframes","keyframes","sampleAnimation","_objectSpread","repeat","delay","isGenerator","state","done","value","pregeneratedKeyframes","t","sample","push","times","undefined","duration","AcceleratedAnimation","_BaseAnimation","_inherits","_super","_createSuper","_this","_classCallCheck","_this$options","name","motionValue","element","resolver","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","_createClass","key","initPlayback","_this2","_a","_this$options2","_this$options2$durati","startTime","owner","current","_this$options3","onComplete","onUpdate","_objectWithoutProperties","_excluded","pregeneratedAnimation","length","animation","calcStartTime","pendingTimeline","timeline","onfinish","set","cancel","resolveFinishedPromise","get","resolved","currentTime","newTime","playbackRate","newSpeed","playState","attachTimeline","_resolved","play","isStopped","updateFinishedPromise","pause","stop","time","_this$options4","_excluded2","sampleTime","setWithVelocity","onStop","complete","finish","supports","repeatDelay","repeatType","damping","has","HTMLElement","getProps"],"sources":["/Users/Ksquare/Documents/Software/home/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs"],"sourcesContent":["import { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { memo } from '../../utils/memo.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { animateStyle } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return options.type === \"spring\" || !isWaapiSupportedEasing(options.ease);\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        var _a;\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n            return false;\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = animateStyle(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            animation.timeline = this.pendingTimeline;\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop;\n            const { animation } = resolved;\n            animation.timeline = timeline;\n            animation.onfinish = null;\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            motionValue &&\n            motionValue.owner &&\n            motionValue.owner.current instanceof HTMLElement &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !motionValue.owner.getProps().onUpdate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}