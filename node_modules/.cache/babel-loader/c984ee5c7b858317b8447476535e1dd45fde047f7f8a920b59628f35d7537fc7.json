{"ast":null,"code":"\"use client\";\n\nimport _toConsumableArray from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function AnimatePresence(_ref) {\n  var children = _ref.children,\n    exitBeforeEnter = _ref.exitBeforeEnter,\n    custom = _ref.custom,\n    _ref$initial = _ref.initial,\n    initial = _ref$initial === void 0 ? true : _ref$initial,\n    onExitComplete = _ref.onExitComplete,\n    _ref$presenceAffectsL = _ref.presenceAffectsLayout,\n    presenceAffectsLayout = _ref$presenceAffectsL === void 0 ? true : _ref$presenceAffectsL,\n    _ref$mode = _ref.mode,\n    mode = _ref$mode === void 0 ? \"sync\" : _ref$mode;\n  invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\n  /**\n   * Filter any children that aren't ReactElements. We can only track components\n   * between renders with a props.key.\n   */\n  var presentChildren = useMemo(function () {\n    return onlyElements(children);\n  }, [children]);\n  /**\n   * Track the keys of the currently rendered children. This is used to\n   * determine which children are exiting.\n   */\n  var presentKeys = presentChildren.map(getChildKey);\n  /**\n   * If `initial={false}` we only want to pass this to components in the first render.\n   */\n  var isInitialRender = useRef(true);\n  /**\n   * A ref containing the currently present children. When all exit animations\n   * are complete, we use this to re-render the component with the latest children\n   * *committed* rather than the latest children *rendered*.\n   */\n  var pendingPresentChildren = useRef(presentChildren);\n  /**\n   * Track which exiting children have finished animating out.\n   */\n  var exitComplete = useConstant(function () {\n    return new Map();\n  });\n  /**\n   * Save children to render as React state. To ensure this component is concurrent-safe,\n   * we check for exiting children via an effect.\n   */\n  var _useState = useState(presentChildren),\n    _useState2 = _slicedToArray(_useState, 2),\n    diffedChildren = _useState2[0],\n    setDiffedChildren = _useState2[1];\n  var _useState3 = useState(presentChildren),\n    _useState4 = _slicedToArray(_useState3, 2),\n    renderedChildren = _useState4[0],\n    setRenderedChildren = _useState4[1];\n  useIsomorphicLayoutEffect(function () {\n    isInitialRender.current = false;\n    pendingPresentChildren.current = presentChildren;\n    /**\n     * Update complete status of exiting children.\n     */\n    for (var i = 0; i < renderedChildren.length; i++) {\n      var key = getChildKey(renderedChildren[i]);\n      if (!presentKeys.includes(key)) {\n        if (exitComplete.get(key) !== true) {\n          exitComplete.set(key, false);\n        }\n      } else {\n        exitComplete.delete(key);\n      }\n    }\n  }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n  var exitingChildren = [];\n  if (presentChildren !== diffedChildren) {\n    var nextChildren = _toConsumableArray(presentChildren);\n    /**\n     * Loop through all the currently rendered components and decide which\n     * are exiting.\n     */\n    for (var i = 0; i < renderedChildren.length; i++) {\n      var child = renderedChildren[i];\n      var key = getChildKey(child);\n      if (!presentKeys.includes(key)) {\n        nextChildren.splice(i, 0, child);\n        exitingChildren.push(child);\n      }\n    }\n    /**\n     * If we're in \"wait\" mode, and we have exiting children, we want to\n     * only render these until they've all exited.\n     */\n    if (mode === \"wait\" && exitingChildren.length) {\n      nextChildren = exitingChildren;\n    }\n    setRenderedChildren(onlyElements(nextChildren));\n    setDiffedChildren(presentChildren);\n    /**\n     * Early return to ensure once we've set state with the latest diffed\n     * children, we can immediately re-render.\n     */\n    return;\n  }\n  if (process.env.NODE_ENV !== \"production\" && mode === \"wait\" && renderedChildren.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its mode is set to \\\"wait\\\". This will lead to odd visual behaviour.\");\n  }\n  /**\n   * If we've been provided a forceRender function by the LayoutGroupContext,\n   * we can use it to force a re-render amongst all surrounding components once\n   * all components have finished animating out.\n   */\n  var _useContext = useContext(LayoutGroupContext),\n    forceRender = _useContext.forceRender;\n  return jsx(Fragment, {\n    children: renderedChildren.map(function (child) {\n      var key = getChildKey(child);\n      var isPresent = presentChildren === renderedChildren || presentKeys.includes(key);\n      var onExit = function onExit() {\n        if (exitComplete.has(key)) {\n          exitComplete.set(key, true);\n        } else {\n          return;\n        }\n        var isEveryExitComplete = true;\n        exitComplete.forEach(function (isExitComplete) {\n          if (!isExitComplete) isEveryExitComplete = false;\n        });\n        if (isEveryExitComplete) {\n          forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n          setRenderedChildren(pendingPresentChildren.current);\n          onExitComplete && onExitComplete();\n        }\n      };\n      return jsx(PresenceChild, {\n        isPresent: isPresent,\n        initial: !isInitialRender.current || initial ? undefined : false,\n        custom: isPresent ? undefined : custom,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode,\n        onExitComplete: isPresent ? undefined : onExit,\n        children: child\n      }, key);\n    })\n  });\n};\nexport { AnimatePresence };","map":{"version":3,"names":["_toConsumableArray","_slicedToArray","jsx","Fragment","useMemo","useRef","useState","useContext","PresenceChild","LayoutGroupContext","invariant","useConstant","onlyElements","getChildKey","useIsomorphicLayoutEffect","AnimatePresence","_ref","children","exitBeforeEnter","custom","_ref$initial","initial","onExitComplete","_ref$presenceAffectsL","presenceAffectsLayout","_ref$mode","mode","presentChildren","presentKeys","map","isInitialRender","pendingPresentChildren","exitComplete","Map","_useState","_useState2","diffedChildren","setDiffedChildren","_useState3","_useState4","renderedChildren","setRenderedChildren","current","i","length","key","includes","get","set","delete","join","exitingChildren","nextChildren","child","splice","push","process","env","NODE_ENV","console","warn","_useContext","forceRender","isPresent","onExit","has","isEveryExitComplete","forEach","isExitComplete","undefined"],"sources":["/Users/Ksquare/Documents/Software/home/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"sourcesContent":["\"use client\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", }) => {\n    invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return;\n    }\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext);\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = presentChildren === renderedChildren ||\n                presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, children: child }, key));\n        }) }));\n};\n\nexport { AnimatePresence };\n"],"mappings":"AAAA,YAAY;;AAAC,OAAAA,kBAAA;AAAA,OAAAC,cAAA;AACb,SAASC,GAAG,EAAEC,QAAQ,QAAQ,mBAAmB;AACjD,SAASC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,UAAU,QAAQ,OAAO;AAC7D,SAASC,aAAa,QAAQ,qBAAqB;AACnD,SAASC,kBAAkB,QAAQ,sCAAsC;AACzE,SAASC,SAAS,QAAQ,wBAAwB;AAClD,SAASC,WAAW,QAAQ,8BAA8B;AAC1D,SAASC,YAAY,EAAEC,WAAW,QAAQ,aAAa;AACvD,SAASC,yBAAyB,QAAQ,uCAAuC;;AAEjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMC,eAAe,GAAG,SAAlBA,eAAeA,CAAAC,IAAA,EAA4H;EAAA,IAAtHC,QAAQ,GAAAD,IAAA,CAARC,QAAQ;IAAEC,eAAe,GAAAF,IAAA,CAAfE,eAAe;IAAEC,MAAM,GAAAH,IAAA,CAANG,MAAM;IAAAC,YAAA,GAAAJ,IAAA,CAAEK,OAAO;IAAPA,OAAO,GAAAD,YAAA,cAAG,IAAI,GAAAA,YAAA;IAAEE,cAAc,GAAAN,IAAA,CAAdM,cAAc;IAAAC,qBAAA,GAAAP,IAAA,CAAEQ,qBAAqB;IAArBA,qBAAqB,GAAAD,qBAAA,cAAG,IAAI,GAAAA,qBAAA;IAAAE,SAAA,GAAAT,IAAA,CAAEU,IAAI;IAAJA,IAAI,GAAAD,SAAA,cAAG,MAAM,GAAAA,SAAA;EACrIf,SAAS,CAAC,CAACQ,eAAe,EAAE,0CAA0C,CAAC;EACvE;AACJ;AACA;AACA;EACI,IAAMS,eAAe,GAAGvB,OAAO,CAAC;IAAA,OAAMQ,YAAY,CAACK,QAAQ,CAAC;EAAA,GAAE,CAACA,QAAQ,CAAC,CAAC;EACzE;AACJ;AACA;AACA;EACI,IAAMW,WAAW,GAAGD,eAAe,CAACE,GAAG,CAAChB,WAAW,CAAC;EACpD;AACJ;AACA;EACI,IAAMiB,eAAe,GAAGzB,MAAM,CAAC,IAAI,CAAC;EACpC;AACJ;AACA;AACA;AACA;EACI,IAAM0B,sBAAsB,GAAG1B,MAAM,CAACsB,eAAe,CAAC;EACtD;AACJ;AACA;EACI,IAAMK,YAAY,GAAGrB,WAAW,CAAC;IAAA,OAAM,IAAIsB,GAAG,CAAC,CAAC;EAAA,EAAC;EACjD;AACJ;AACA;AACA;EACI,IAAAC,SAAA,GAA4C5B,QAAQ,CAACqB,eAAe,CAAC;IAAAQ,UAAA,GAAAlC,cAAA,CAAAiC,SAAA;IAA9DE,cAAc,GAAAD,UAAA;IAAEE,iBAAiB,GAAAF,UAAA;EACxC,IAAAG,UAAA,GAAgDhC,QAAQ,CAACqB,eAAe,CAAC;IAAAY,UAAA,GAAAtC,cAAA,CAAAqC,UAAA;IAAlEE,gBAAgB,GAAAD,UAAA;IAAEE,mBAAmB,GAAAF,UAAA;EAC5CzB,yBAAyB,CAAC,YAAM;IAC5BgB,eAAe,CAACY,OAAO,GAAG,KAAK;IAC/BX,sBAAsB,CAACW,OAAO,GAAGf,eAAe;IAChD;AACR;AACA;IACQ,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,gBAAgB,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;MAC9C,IAAME,GAAG,GAAGhC,WAAW,CAAC2B,gBAAgB,CAACG,CAAC,CAAC,CAAC;MAC5C,IAAI,CAACf,WAAW,CAACkB,QAAQ,CAACD,GAAG,CAAC,EAAE;QAC5B,IAAIb,YAAY,CAACe,GAAG,CAACF,GAAG,CAAC,KAAK,IAAI,EAAE;UAChCb,YAAY,CAACgB,GAAG,CAACH,GAAG,EAAE,KAAK,CAAC;QAChC;MACJ,CAAC,MACI;QACDb,YAAY,CAACiB,MAAM,CAACJ,GAAG,CAAC;MAC5B;IACJ;EACJ,CAAC,EAAE,CAACL,gBAAgB,EAAEZ,WAAW,CAACgB,MAAM,EAAEhB,WAAW,CAACsB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;EACjE,IAAMC,eAAe,GAAG,EAAE;EAC1B,IAAIxB,eAAe,KAAKS,cAAc,EAAE;IACpC,IAAIgB,YAAY,GAAApD,kBAAA,CAAO2B,eAAe,CAAC;IACvC;AACR;AACA;AACA;IACQ,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,gBAAgB,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;MAC9C,IAAMU,KAAK,GAAGb,gBAAgB,CAACG,CAAC,CAAC;MACjC,IAAME,GAAG,GAAGhC,WAAW,CAACwC,KAAK,CAAC;MAC9B,IAAI,CAACzB,WAAW,CAACkB,QAAQ,CAACD,GAAG,CAAC,EAAE;QAC5BO,YAAY,CAACE,MAAM,CAACX,CAAC,EAAE,CAAC,EAAEU,KAAK,CAAC;QAChCF,eAAe,CAACI,IAAI,CAACF,KAAK,CAAC;MAC/B;IACJ;IACA;AACR;AACA;AACA;IACQ,IAAI3B,IAAI,KAAK,MAAM,IAAIyB,eAAe,CAACP,MAAM,EAAE;MAC3CQ,YAAY,GAAGD,eAAe;IAClC;IACAV,mBAAmB,CAAC7B,YAAY,CAACwC,YAAY,CAAC,CAAC;IAC/Cf,iBAAiB,CAACV,eAAe,CAAC;IAClC;AACR;AACA;AACA;IACQ;EACJ;EACA,IAAI6B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IACrChC,IAAI,KAAK,MAAM,IACfc,gBAAgB,CAACI,MAAM,GAAG,CAAC,EAAE;IAC7Be,OAAO,CAACC,IAAI,kJAAgJ,CAAC;EACjK;EACA;AACJ;AACA;AACA;AACA;EACI,IAAAC,WAAA,GAAwBtD,UAAU,CAACE,kBAAkB,CAAC;IAA9CqD,WAAW,GAAAD,WAAA,CAAXC,WAAW;EACnB,OAAQ5D,GAAG,CAACC,QAAQ,EAAE;IAAEc,QAAQ,EAAEuB,gBAAgB,CAACX,GAAG,CAAC,UAACwB,KAAK,EAAK;MAC1D,IAAMR,GAAG,GAAGhC,WAAW,CAACwC,KAAK,CAAC;MAC9B,IAAMU,SAAS,GAAGpC,eAAe,KAAKa,gBAAgB,IAClDZ,WAAW,CAACkB,QAAQ,CAACD,GAAG,CAAC;MAC7B,IAAMmB,MAAM,GAAG,SAATA,MAAMA,CAAA,EAAS;QACjB,IAAIhC,YAAY,CAACiC,GAAG,CAACpB,GAAG,CAAC,EAAE;UACvBb,YAAY,CAACgB,GAAG,CAACH,GAAG,EAAE,IAAI,CAAC;QAC/B,CAAC,MACI;UACD;QACJ;QACA,IAAIqB,mBAAmB,GAAG,IAAI;QAC9BlC,YAAY,CAACmC,OAAO,CAAC,UAACC,cAAc,EAAK;UACrC,IAAI,CAACA,cAAc,EACfF,mBAAmB,GAAG,KAAK;QACnC,CAAC,CAAC;QACF,IAAIA,mBAAmB,EAAE;UACrBJ,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAAC,CAAC;UACvErB,mBAAmB,CAACV,sBAAsB,CAACW,OAAO,CAAC;UACnDpB,cAAc,IAAIA,cAAc,CAAC,CAAC;QACtC;MACJ,CAAC;MACD,OAAQpB,GAAG,CAACM,aAAa,EAAE;QAAEuD,SAAS,EAAEA,SAAS;QAAE1C,OAAO,EAAE,CAACS,eAAe,CAACY,OAAO,IAAIrB,OAAO,GACrFgD,SAAS,GACT,KAAK;QAAElD,MAAM,EAAE4C,SAAS,GAAGM,SAAS,GAAGlD,MAAM;QAAEK,qBAAqB,EAAEA,qBAAqB;QAAEE,IAAI,EAAEA,IAAI;QAAEJ,cAAc,EAAEyC,SAAS,GAAGM,SAAS,GAAGL,MAAM;QAAE/C,QAAQ,EAAEoC;MAAM,CAAC,EAAER,GAAG,CAAC;IAC9L,CAAC;EAAE,CAAC,CAAC;AACb,CAAC;AAED,SAAS9B,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}