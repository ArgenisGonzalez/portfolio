{"ast":null,"code":"import _objectSpread from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _excluded = [\"autoplay\", \"delay\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\"];\nimport { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nvar MAX_RESOLVE_DELAY = 40;\nvar BaseAnimation = /*#__PURE__*/function () {\n  function BaseAnimation(_ref) {\n    var _ref$autoplay = _ref.autoplay,\n      autoplay = _ref$autoplay === void 0 ? true : _ref$autoplay,\n      _ref$delay = _ref.delay,\n      delay = _ref$delay === void 0 ? 0 : _ref$delay,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? \"keyframes\" : _ref$type,\n      _ref$repeat = _ref.repeat,\n      repeat = _ref$repeat === void 0 ? 0 : _ref$repeat,\n      _ref$repeatDelay = _ref.repeatDelay,\n      repeatDelay = _ref$repeatDelay === void 0 ? 0 : _ref$repeatDelay,\n      _ref$repeatType = _ref.repeatType,\n      repeatType = _ref$repeatType === void 0 ? \"loop\" : _ref$repeatType,\n      options = _objectWithoutProperties(_ref, _excluded);\n    _classCallCheck(this, BaseAnimation);\n    // Track whether the animation has been stopped. Stopped animations won't restart.\n    this.isStopped = false;\n    this.hasAttemptedResolve = false;\n    this.createdAt = time.now();\n    this.options = _objectSpread({\n      autoplay: autoplay,\n      delay: delay,\n      type: type,\n      repeat: repeat,\n      repeatDelay: repeatDelay,\n      repeatType: repeatType\n    }, options);\n    this.updateFinishedPromise();\n  }\n  /**\n   * This method uses the createdAt and resolvedAt to calculate the\n   * animation startTime. *Ideally*, we would use the createdAt time as t=0\n   * as the following frame would then be the first frame of the animation in\n   * progress, which would feel snappier.\n   *\n   * However, if there's a delay (main thread work) between the creation of\n   * the animation and the first commited frame, we prefer to use resolvedAt\n   * to avoid a sudden jump into the animation.\n   */\n  _createClass(BaseAnimation, [{\n    key: \"calcStartTime\",\n    value: function calcStartTime() {\n      if (!this.resolvedAt) return this.createdAt;\n      return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n  }, {\n    key: \"resolved\",\n    get: function get() {\n      if (!this._resolved && !this.hasAttemptedResolve) {\n        flushKeyframeResolvers();\n      }\n      return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n  }, {\n    key: \"onKeyframesResolved\",\n    value: function onKeyframesResolved(keyframes, finalKeyframe) {\n      this.resolvedAt = time.now();\n      this.hasAttemptedResolve = true;\n      var _this$options = this.options,\n        name = _this$options.name,\n        type = _this$options.type,\n        velocity = _this$options.velocity,\n        delay = _this$options.delay,\n        onComplete = _this$options.onComplete,\n        onUpdate = _this$options.onUpdate,\n        isGenerator = _this$options.isGenerator;\n      /**\n       * If we can't animate this value with the resolved keyframes\n       * then we should complete it immediately.\n       */\n      if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n        // Finish immediately\n        if (instantAnimationState.current || !delay) {\n          onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n          onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n          this.resolveFinishedPromise();\n          return;\n        }\n        // Finish after a delay\n        else {\n          this.options.duration = 0;\n        }\n      }\n      var resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n      if (resolvedAnimation === false) return;\n      this._resolved = _objectSpread({\n        keyframes: keyframes,\n        finalKeyframe: finalKeyframe\n      }, resolvedAnimation);\n      this.onPostResolved();\n    }\n  }, {\n    key: \"onPostResolved\",\n    value: function onPostResolved() {}\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n  }, {\n    key: \"then\",\n    value: function then(resolve, reject) {\n      return this.currentFinishedPromise.then(resolve, reject);\n    }\n  }, {\n    key: \"updateFinishedPromise\",\n    value: function updateFinishedPromise() {\n      var _this = this;\n      this.currentFinishedPromise = new Promise(function (resolve) {\n        _this.resolveFinishedPromise = resolve;\n      });\n    }\n  }]);\n  return BaseAnimation;\n}();\nexport { BaseAnimation };","map":{"version":3,"names":["time","flushKeyframeResolvers","instantAnimationState","canAnimate","getFinalKeyframe","MAX_RESOLVE_DELAY","BaseAnimation","_ref","_ref$autoplay","autoplay","_ref$delay","delay","_ref$type","type","_ref$repeat","repeat","_ref$repeatDelay","repeatDelay","_ref$repeatType","repeatType","options","_objectWithoutProperties","_excluded","_classCallCheck","isStopped","hasAttemptedResolve","createdAt","now","_objectSpread","updateFinishedPromise","_createClass","key","value","calcStartTime","resolvedAt","get","_resolved","onKeyframesResolved","keyframes","finalKeyframe","_this$options","name","velocity","onComplete","onUpdate","isGenerator","current","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","_this","Promise"],"sources":["/Users/Ksquare/Documents/Software/home/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs"],"sourcesContent":["import { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\nexport { BaseAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}