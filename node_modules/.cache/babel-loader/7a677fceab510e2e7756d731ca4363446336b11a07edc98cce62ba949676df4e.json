{"ast":null,"code":"import _toConsumableArray from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _slicedToArray from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nvar toResolve = new Set();\nvar isScheduled = false;\nvar anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n  if (anyNeedsMeasurement) {\n    var resolversToMeasure = Array.from(toResolve).filter(function (resolver) {\n      return resolver.needsMeasurement;\n    });\n    var elementsToMeasure = new Set(resolversToMeasure.map(function (resolver) {\n      return resolver.element;\n    }));\n    var transformsToRestore = new Map();\n    /**\n     * Write pass\n     * If we're measuring elements we want to remove bounding box-changing transforms.\n     */\n    elementsToMeasure.forEach(function (element) {\n      var removedTransforms = removeNonTranslationalTransform(element);\n      if (!removedTransforms.length) return;\n      transformsToRestore.set(element, removedTransforms);\n      element.render();\n    });\n    // Read\n    resolversToMeasure.forEach(function (resolver) {\n      return resolver.measureInitialState();\n    });\n    // Write\n    elementsToMeasure.forEach(function (element) {\n      element.render();\n      var restore = transformsToRestore.get(element);\n      if (restore) {\n        restore.forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n          var _a;\n          (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n        });\n      }\n    });\n    // Read\n    resolversToMeasure.forEach(function (resolver) {\n      return resolver.measureEndState();\n    });\n    // Write\n    resolversToMeasure.forEach(function (resolver) {\n      if (resolver.suspendedScrollY !== undefined) {\n        window.scrollTo(0, resolver.suspendedScrollY);\n      }\n    });\n  }\n  anyNeedsMeasurement = false;\n  isScheduled = false;\n  toResolve.forEach(function (resolver) {\n    return resolver.complete();\n  });\n  toResolve.clear();\n}\nfunction readAllKeyframes() {\n  toResolve.forEach(function (resolver) {\n    resolver.readKeyframes();\n    if (resolver.needsMeasurement) {\n      anyNeedsMeasurement = true;\n    }\n  });\n}\nfunction flushKeyframeResolvers() {\n  readAllKeyframes();\n  measureAllKeyframes();\n}\nvar KeyframeResolver = /*#__PURE__*/function () {\n  function KeyframeResolver(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    var isAsync = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    _classCallCheck(this, KeyframeResolver);\n    /**\n     * Track whether this resolver has completed. Once complete, it never\n     * needs to attempt keyframe resolution again.\n     */\n    this.isComplete = false;\n    /**\n     * Track whether this resolver is async. If it is, it'll be added to the\n     * resolver queue and flushed in the next frame. Resolvers that aren't going\n     * to trigger read/write thrashing don't need to be async.\n     */\n    this.isAsync = false;\n    /**\n     * Track whether this resolver needs to perform a measurement\n     * to resolve its keyframes.\n     */\n    this.needsMeasurement = false;\n    /**\n     * Track whether this resolver is currently scheduled to resolve\n     * to allow it to be cancelled and resumed externally.\n     */\n    this.isScheduled = false;\n    this.unresolvedKeyframes = _toConsumableArray(unresolvedKeyframes);\n    this.onComplete = onComplete;\n    this.name = name;\n    this.motionValue = motionValue;\n    this.element = element;\n    this.isAsync = isAsync;\n  }\n  _createClass(KeyframeResolver, [{\n    key: \"scheduleResolve\",\n    value: function scheduleResolve() {\n      this.isScheduled = true;\n      if (this.isAsync) {\n        toResolve.add(this);\n        if (!isScheduled) {\n          isScheduled = true;\n          frame.read(readAllKeyframes);\n          frame.resolveKeyframes(measureAllKeyframes);\n        }\n      } else {\n        this.readKeyframes();\n        this.complete();\n      }\n    }\n  }, {\n    key: \"readKeyframes\",\n    value: function readKeyframes() {\n      var unresolvedKeyframes = this.unresolvedKeyframes,\n        name = this.name,\n        element = this.element,\n        motionValue = this.motionValue;\n      /**\n       * If a keyframe is null, we hydrate it either by reading it from\n       * the instance, or propagating from previous keyframes.\n       */\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        if (unresolvedKeyframes[i] === null) {\n          /**\n           * If the first keyframe is null, we need to find its value by sampling the element\n           */\n          if (i === 0) {\n            var currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n            var finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n            if (currentValue !== undefined) {\n              unresolvedKeyframes[0] = currentValue;\n            } else if (element && name) {\n              var valueAsRead = element.readValue(name, finalKeyframe);\n              if (valueAsRead !== undefined && valueAsRead !== null) {\n                unresolvedKeyframes[0] = valueAsRead;\n              }\n            }\n            if (unresolvedKeyframes[0] === undefined) {\n              unresolvedKeyframes[0] = finalKeyframe;\n            }\n            if (motionValue && currentValue === undefined) {\n              motionValue.set(unresolvedKeyframes[0]);\n            }\n          } else {\n            unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"setFinalKeyframe\",\n    value: function setFinalKeyframe() {}\n  }, {\n    key: \"measureInitialState\",\n    value: function measureInitialState() {}\n  }, {\n    key: \"renderEndStyles\",\n    value: function renderEndStyles() {}\n  }, {\n    key: \"measureEndState\",\n    value: function measureEndState() {}\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.isComplete = true;\n      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n      toResolve.delete(this);\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (!this.isComplete) {\n        this.isScheduled = false;\n        toResolve.delete(this);\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (!this.isComplete) this.scheduleResolve();\n    }\n  }]);\n  return KeyframeResolver;\n}();\nexport { KeyframeResolver, flushKeyframeResolvers };","map":{"version":3,"names":["removeNonTranslationalTransform","frame","toResolve","Set","isScheduled","anyNeedsMeasurement","measureAllKeyframes","resolversToMeasure","Array","from","filter","resolver","needsMeasurement","elementsToMeasure","map","element","transformsToRestore","Map","forEach","removedTransforms","length","set","render","measureInitialState","restore","get","_ref","_ref2","_slicedToArray","key","value","_a","getValue","measureEndState","suspendedScrollY","undefined","window","scrollTo","complete","clear","readAllKeyframes","readKeyframes","flushKeyframeResolvers","KeyframeResolver","unresolvedKeyframes","onComplete","name","motionValue","isAsync","arguments","_classCallCheck","isComplete","_toConsumableArray","_createClass","scheduleResolve","add","read","resolveKeyframes","i","currentValue","finalKeyframe","valueAsRead","readValue","setFinalKeyframe","renderEndStyles","delete","cancel","resume"],"sources":["/Users/Ksquare/Documents/Software/home/node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs"],"sourcesContent":["import { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    var _a;\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete());\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    readAllKeyframes();\n    measureAllKeyframes();\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        /**\n         * Track whether this resolver has completed. Once complete, it never\n         * needs to attempt keyframe resolution again.\n         */\n        this.isComplete = false;\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        /**\n         * Track whether this resolver is currently scheduled to resolve\n         * to allow it to be cancelled and resumed externally.\n         */\n        this.isScheduled = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.isScheduled = true;\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        /**\n         * If a keyframe is null, we hydrate it either by reading it from\n         * the instance, or propagating from previous keyframes.\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null) {\n                /**\n                 * If the first keyframe is null, we need to find its value by sampling the element\n                 */\n                if (i === 0) {\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n                    if (currentValue !== undefined) {\n                        unresolvedKeyframes[0] = currentValue;\n                    }\n                    else if (element && name) {\n                        const valueAsRead = element.readValue(name, finalKeyframe);\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\n                            unresolvedKeyframes[0] = valueAsRead;\n                        }\n                    }\n                    if (unresolvedKeyframes[0] === undefined) {\n                        unresolvedKeyframes[0] = finalKeyframe;\n                    }\n                    if (motionValue && currentValue === undefined) {\n                        motionValue.set(unresolvedKeyframes[0]);\n                    }\n                }\n                else {\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n                }\n            }\n        }\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete() {\n        this.isComplete = true;\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (!this.isComplete) {\n            this.isScheduled = false;\n            toResolve.delete(this);\n        }\n    }\n    resume() {\n        if (!this.isComplete)\n            this.scheduleResolve();\n    }\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}