{"ast":null,"code":"import _toConsumableArray from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { calcGeneratorDuration } from '../generators/utils/calc-duration.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nvar generators = {\n  decay: inertia,\n  inertia: inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring: spring\n};\nvar percentToProgress = function percentToProgress(percent) {\n  return percent / 100;\n};\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nvar MainThreadAnimation = /*#__PURE__*/function (_BaseAnimation) {\n  _inherits(MainThreadAnimation, _BaseAnimation);\n  var _super = _createSuper(MainThreadAnimation);\n  function MainThreadAnimation(options) {\n    var _this;\n    _classCallCheck(this, MainThreadAnimation);\n    _this = _super.call(this, options);\n    /**\n     * The time at which the animation was paused.\n     */\n    _this.holdTime = null;\n    /**\n     * The time at which the animation was cancelled.\n     */\n    _this.cancelTime = null;\n    /**\n     * The current time of the animation.\n     */\n    _this.currentTime = 0;\n    /**\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n     */\n    _this.playbackSpeed = 1;\n    /**\n     * The state of the animation to apply when the animation is resolved. This\n     * allows calls to the public API to control the animation before it is resolved,\n     * without us having to resolve it first.\n     */\n    _this.pendingPlayState = \"running\";\n    /**\n     * The time at which the animation was started.\n     */\n    _this.startTime = null;\n    _this.state = \"idle\";\n    /**\n     * This method is bound to the instance to fix a pattern where\n     * animation.stop is returned as a reference from a useEffect.\n     */\n    _this.stop = function () {\n      _this.resolver.cancel();\n      _this.isStopped = true;\n      if (_this.state === \"idle\") return;\n      _this.teardown();\n      var onStop = _this.options.onStop;\n      onStop && onStop();\n    };\n    var _this$options = _this.options,\n      name = _this$options.name,\n      motionValue = _this$options.motionValue,\n      element = _this$options.element,\n      keyframes = _this$options.keyframes;\n    var KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n    var onResolved = function onResolved(resolvedKeyframes, finalKeyframe) {\n      return _this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    };\n    _this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n    _this.resolver.scheduleResolve();\n    return _this;\n  }\n  _createClass(MainThreadAnimation, [{\n    key: \"initPlayback\",\n    value: function initPlayback(keyframes$1) {\n      var _this$options2 = this.options,\n        _this$options2$type = _this$options2.type,\n        type = _this$options2$type === void 0 ? \"keyframes\" : _this$options2$type,\n        _this$options2$repeat = _this$options2.repeat,\n        repeat = _this$options2$repeat === void 0 ? 0 : _this$options2$repeat,\n        _this$options2$repeat2 = _this$options2.repeatDelay,\n        repeatDelay = _this$options2$repeat2 === void 0 ? 0 : _this$options2$repeat2,\n        repeatType = _this$options2.repeatType,\n        _this$options2$veloci = _this$options2.velocity,\n        velocity = _this$options2$veloci === void 0 ? 0 : _this$options2$veloci;\n      var generatorFactory = generators[type] || keyframes;\n      /**\n       * If our generator doesn't support mixing numbers, we need to replace keyframes with\n       * [0, 100] and then make a function that maps that to the actual keyframes.\n       *\n       * 100 is chosen instead of 1 as it works nicer with spring animations.\n       */\n      var mapPercentToKeyframes;\n      var mirroredGenerator;\n      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n        if (process.env.NODE_ENV !== \"production\") {\n          invariant(keyframes$1.length === 2, \"Only two keyframes currently supported with spring and inertia animations. Trying to animate \".concat(keyframes$1));\n        }\n        mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n        keyframes$1 = [0, 100];\n      }\n      var generator = generatorFactory(_objectSpread(_objectSpread({}, this.options), {}, {\n        keyframes: keyframes$1\n      }));\n      /**\n       * If we have a mirror repeat type we need to create a second generator that outputs the\n       * mirrored (not reversed) animation and later ping pong between the two generators.\n       */\n      if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory(_objectSpread(_objectSpread({}, this.options), {}, {\n          keyframes: _toConsumableArray(keyframes$1).reverse(),\n          velocity: -velocity\n        }));\n      }\n      /**\n       * If duration is undefined and we have repeat options,\n       * we need to calculate a duration from the generator.\n       *\n       * We set it to the generator itself to cache the duration.\n       * Any timeline resolver will need to have already precalculated\n       * the duration by this step.\n       */\n      if (generator.calculatedDuration === null) {\n        generator.calculatedDuration = calcGeneratorDuration(generator);\n      }\n      var calculatedDuration = generator.calculatedDuration;\n      var resolvedDuration = calculatedDuration + repeatDelay;\n      var totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n      return {\n        generator: generator,\n        mirroredGenerator: mirroredGenerator,\n        mapPercentToKeyframes: mapPercentToKeyframes,\n        calculatedDuration: calculatedDuration,\n        resolvedDuration: resolvedDuration,\n        totalDuration: totalDuration\n      };\n    }\n  }, {\n    key: \"onPostResolved\",\n    value: function onPostResolved() {\n      var _this$options$autopla = this.options.autoplay,\n        autoplay = _this$options$autopla === void 0 ? true : _this$options$autopla;\n      this.play();\n      if (this.pendingPlayState === \"paused\" || !autoplay) {\n        this.pause();\n      } else {\n        this.state = this.pendingPlayState;\n      }\n    }\n  }, {\n    key: \"tick\",\n    value: function tick(timestamp) {\n      var sample = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var resolved = this.resolved;\n      // If the animations has failed to resolve, return the final keyframe.\n      if (!resolved) {\n        var _keyframes = this.options.keyframes;\n        return {\n          done: true,\n          value: _keyframes[_keyframes.length - 1]\n        };\n      }\n      var finalKeyframe = resolved.finalKeyframe,\n        generator = resolved.generator,\n        mirroredGenerator = resolved.mirroredGenerator,\n        mapPercentToKeyframes = resolved.mapPercentToKeyframes,\n        keyframes = resolved.keyframes,\n        calculatedDuration = resolved.calculatedDuration,\n        totalDuration = resolved.totalDuration,\n        resolvedDuration = resolved.resolvedDuration;\n      if (this.startTime === null) return generator.next(0);\n      var _this$options3 = this.options,\n        delay = _this$options3.delay,\n        repeat = _this$options3.repeat,\n        repeatType = _this$options3.repeatType,\n        repeatDelay = _this$options3.repeatDelay,\n        onUpdate = _this$options3.onUpdate;\n      /**\n       * requestAnimationFrame timestamps can come through as lower than\n       * the startTime as set by performance.now(). Here we prevent this,\n       * though in the future it could be possible to make setting startTime\n       * a pending operation that gets resolved here.\n       */\n      if (this.speed > 0) {\n        this.startTime = Math.min(this.startTime, timestamp);\n      } else if (this.speed < 0) {\n        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n      }\n      // Update currentTime\n      if (sample) {\n        this.currentTime = timestamp;\n      } else if (this.holdTime !== null) {\n        this.currentTime = this.holdTime;\n      } else {\n        // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n        // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n        // example.\n        this.currentTime = Math.round(timestamp - this.startTime) * this.speed;\n      }\n      // Rebase on delay\n      var timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n      var isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n      this.currentTime = Math.max(timeWithoutDelay, 0);\n      // If this animation has finished, set the current time  to the total duration.\n      if (this.state === \"finished\" && this.holdTime === null) {\n        this.currentTime = totalDuration;\n      }\n      var elapsed = this.currentTime;\n      var frameGenerator = generator;\n      if (repeat) {\n        /**\n         * Get the current progress (0-1) of the animation. If t is >\n         * than duration we'll get values like 2.5 (midway through the\n         * third iteration)\n         */\n        var progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n        /**\n         * Get the current iteration (0 indexed). For instance the floor of\n         * 2.5 is 2.\n         */\n        var currentIteration = Math.floor(progress);\n        /**\n         * Get the current progress of the iteration by taking the remainder\n         * so 2.5 is 0.5 through iteration 2\n         */\n        var iterationProgress = progress % 1.0;\n        /**\n         * If iteration progress is 1 we count that as the end\n         * of the previous iteration.\n         */\n        if (!iterationProgress && progress >= 1) {\n          iterationProgress = 1;\n        }\n        iterationProgress === 1 && currentIteration--;\n        currentIteration = Math.min(currentIteration, repeat + 1);\n        /**\n         * Reverse progress if we're not running in \"normal\" direction\n         */\n        var isOddIteration = Boolean(currentIteration % 2);\n        if (isOddIteration) {\n          if (repeatType === \"reverse\") {\n            iterationProgress = 1 - iterationProgress;\n            if (repeatDelay) {\n              iterationProgress -= repeatDelay / resolvedDuration;\n            }\n          } else if (repeatType === \"mirror\") {\n            frameGenerator = mirroredGenerator;\n          }\n        }\n        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n      }\n      /**\n       * If we're in negative time, set state as the initial keyframe.\n       * This prevents delay: x, duration: 0 animations from finishing\n       * instantly.\n       */\n      var state = isInDelayPhase ? {\n        done: false,\n        value: keyframes[0]\n      } : frameGenerator.next(elapsed);\n      if (mapPercentToKeyframes) {\n        state.value = mapPercentToKeyframes(state.value);\n      }\n      var done = state.done;\n      if (!isInDelayPhase && calculatedDuration !== null) {\n        done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n      }\n      var isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done);\n      if (isAnimationFinished && finalKeyframe !== undefined) {\n        state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n      }\n      if (onUpdate) {\n        onUpdate(state.value);\n      }\n      if (isAnimationFinished) {\n        this.finish();\n      }\n      return state;\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var resolved = this.resolved;\n      return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      return millisecondsToSeconds(this.currentTime);\n    },\n    set: function set(newTime) {\n      newTime = secondsToMilliseconds(newTime);\n      this.currentTime = newTime;\n      if (this.holdTime !== null || this.speed === 0) {\n        this.holdTime = newTime;\n      } else if (this.driver) {\n        this.startTime = this.driver.now() - newTime / this.speed;\n      }\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      return this.playbackSpeed;\n    },\n    set: function set(newSpeed) {\n      var hasChanged = this.playbackSpeed !== newSpeed;\n      this.playbackSpeed = newSpeed;\n      if (hasChanged) {\n        this.time = millisecondsToSeconds(this.currentTime);\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      var _this2 = this;\n      if (!this.resolver.isScheduled) {\n        this.resolver.resume();\n      }\n      if (!this._resolved) {\n        this.pendingPlayState = \"running\";\n        return;\n      }\n      if (this.isStopped) return;\n      var _this$options4 = this.options,\n        _this$options4$driver = _this$options4.driver,\n        driver = _this$options4$driver === void 0 ? frameloopDriver : _this$options4$driver,\n        onPlay = _this$options4.onPlay,\n        startTime = _this$options4.startTime;\n      if (!this.driver) {\n        this.driver = driver(function (timestamp) {\n          return _this2.tick(timestamp);\n        });\n      }\n      onPlay && onPlay();\n      var now = this.driver.now();\n      if (this.holdTime !== null) {\n        this.startTime = now - this.holdTime;\n      } else if (!this.startTime) {\n        this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n      } else if (this.state === \"finished\") {\n        this.startTime = now;\n      }\n      if (this.state === \"finished\") {\n        this.updateFinishedPromise();\n      }\n      this.cancelTime = this.startTime;\n      this.holdTime = null;\n      /**\n       * Set playState to running only after we've used it in\n       * the previous logic.\n       */\n      this.state = \"running\";\n      this.driver.start();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var _a;\n      if (!this._resolved) {\n        this.pendingPlayState = \"paused\";\n        return;\n      }\n      this.state = \"paused\";\n      this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      if (this.state !== \"running\") {\n        this.play();\n      }\n      this.pendingPlayState = this.state = \"finished\";\n      this.holdTime = null;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.teardown();\n      this.state = \"finished\";\n      var onComplete = this.options.onComplete;\n      onComplete && onComplete();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.cancelTime !== null) {\n        this.tick(this.cancelTime);\n      }\n      this.teardown();\n      this.updateFinishedPromise();\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      this.state = \"idle\";\n      this.stopDriver();\n      this.resolveFinishedPromise();\n      this.updateFinishedPromise();\n      this.startTime = this.cancelTime = null;\n      this.resolver.cancel();\n    }\n  }, {\n    key: \"stopDriver\",\n    value: function stopDriver() {\n      if (!this.driver) return;\n      this.driver.stop();\n      this.driver = undefined;\n    }\n  }, {\n    key: \"sample\",\n    value: function sample(time) {\n      this.startTime = 0;\n      return this.tick(time, true);\n    }\n  }]);\n  return MainThreadAnimation;\n}(BaseAnimation); // Legacy interface\nfunction animateValue(options) {\n  return new MainThreadAnimation(options);\n}\nexport { MainThreadAnimation, animateValue };","map":{"version":3,"names":["KeyframeResolver","spring","inertia","keyframes","BaseAnimation","pipe","mix","calcGeneratorDuration","millisecondsToSeconds","secondsToMilliseconds","clamp","invariant","frameloopDriver","getFinalKeyframe","generators","decay","tween","percentToProgress","percent","MainThreadAnimation","_BaseAnimation","_inherits","_super","_createSuper","options","_this","_classCallCheck","call","holdTime","cancelTime","currentTime","playbackSpeed","pendingPlayState","startTime","state","stop","resolver","cancel","isStopped","teardown","onStop","_this$options","name","motionValue","element","KeyframeResolver$1","onResolved","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","_createClass","key","value","initPlayback","keyframes$1","_this$options2","_this$options2$type","type","_this$options2$repeat","repeat","_this$options2$repeat2","repeatDelay","repeatType","_this$options2$veloci","velocity","generatorFactory","mapPercentToKeyframes","mirroredGenerator","process","env","NODE_ENV","length","concat","generator","_objectSpread","_toConsumableArray","reverse","calculatedDuration","resolvedDuration","totalDuration","onPostResolved","_this$options$autopla","autoplay","play","pause","tick","timestamp","sample","arguments","undefined","resolved","done","next","_this$options3","delay","onUpdate","speed","Math","min","round","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","isAnimationFinished","finish","get","set","newTime","driver","now","newSpeed","hasChanged","time","_this2","isScheduled","resume","_resolved","_this$options4","_this$options4$driver","onPlay","calcStartTime","updateFinishedPromise","start","_a","complete","onComplete","stopDriver","resolveFinishedPromise","animateValue"],"sources":["/Users/Ksquare/Documents/Software/home/node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs"],"sourcesContent":["import { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { calcGeneratorDuration } from '../generators/utils/calc-duration.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst generators = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\nconst percentToProgress = (percent) => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nclass MainThreadAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */\n        this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */\n        this.pendingPlayState = \"running\";\n        /**\n         * The time at which the animation was started.\n         */\n        this.startTime = null;\n        this.state = \"idle\";\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            this.resolver.cancel();\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        const { name, motionValue, element, keyframes } = this.options;\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes$1) {\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\n        const generatorFactory = generators[type] || keyframes;\n        /**\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */\n        let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            if (process.env.NODE_ENV !== \"production\") {\n                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n            }\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration,\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        this.play();\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\n            this.pause();\n        }\n        else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return { done: true, value: keyframes[keyframes.length - 1] };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime =\n                Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.speed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = \"running\";\n            return;\n        }\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        }\n        else if (this.state === \"finished\") {\n            this.startTime = now;\n        }\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = \"paused\";\n            return;\n        }\n        this.state = \"paused\";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}