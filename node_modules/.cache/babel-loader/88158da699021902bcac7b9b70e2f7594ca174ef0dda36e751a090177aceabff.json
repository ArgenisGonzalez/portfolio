{"ast":null,"code":"import _objectSpread from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getValueTransition, isTransitionDefined } from '../utils/transitions.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { GroupPlaybackControls } from '../GroupPlaybackControls.mjs';\nvar animateMotionValue = function animateMotionValue(name, value, target) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var element = arguments.length > 4 ? arguments[4] : undefined;\n  var isHandoff = arguments.length > 5 ? arguments[5] : undefined;\n  var\n  /**\n   * Currently used to remove values from will-change when an animation ends.\n   * Preferably this would be handled by event listeners on the MotionValue\n   * but these aren't consistent enough yet when considering the different ways\n   * an animation can be cancelled.\n   */\n  onEnd = arguments.length > 6 ? arguments[6] : undefined;\n  return function (_onComplete) {\n    var valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    var delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    var _transition$elapsed = transition.elapsed,\n      elapsed = _transition$elapsed === void 0 ? 0 : _transition$elapsed;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    var options = _objectSpread(_objectSpread({\n      keyframes: Array.isArray(target) ? target : [null, target],\n      ease: \"easeOut\",\n      velocity: value.getVelocity()\n    }, valueTransition), {}, {\n      delay: -elapsed,\n      onUpdate: function onUpdate(v) {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: function onComplete() {\n        _onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n        onEnd && onEnd();\n      },\n      onStop: onEnd,\n      name: name,\n      motionValue: value,\n      element: isHandoff ? undefined : element\n    });\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n      options = _objectSpread(_objectSpread({}, options), getDefaultTransition(name, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n      options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n      options.keyframes[0] = options.from;\n    }\n    var shouldSkip = false;\n    if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n      options.duration = 0;\n      if (options.delay === 0) {\n        shouldSkip = true;\n      }\n    }\n    if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {\n      shouldSkip = true;\n      options.duration = 0;\n      options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n      var finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n      if (finalKeyframe !== undefined) {\n        frame.update(function () {\n          options.onUpdate(finalKeyframe);\n          options.onComplete();\n        });\n        // We still want to return some animation controls here rather\n        // than returning undefined\n        return new GroupPlaybackControls([]);\n      }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n      return new AcceleratedAnimation(options);\n    } else {\n      return new MainThreadAnimation(options);\n    }\n  };\n};\nexport { animateMotionValue };","map":{"version":3,"names":["secondsToMilliseconds","getDefaultTransition","getValueTransition","isTransitionDefined","MotionGlobalConfig","instantAnimationState","getFinalKeyframe","frame","AcceleratedAnimation","MainThreadAnimation","GroupPlaybackControls","animateMotionValue","name","value","target","transition","arguments","length","undefined","element","isHandoff","onEnd","onComplete","valueTransition","delay","_transition$elapsed","elapsed","options","_objectSpread","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","onStop","motionValue","duration","repeatDelay","from","shouldSkip","type","current","skipAnimations","get","finalKeyframe","update","supports"],"sources":["/Users/Ksquare/Documents/Software/home/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getValueTransition, isTransitionDefined } from '../utils/transitions.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { GroupPlaybackControls } from '../GroupPlaybackControls.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff, \n/**\n * Currently used to remove values from will-change when an animation ends.\n * Preferably this would be handled by event listeners on the MotionValue\n * but these aren't consistent enough yet when considering the different ways\n * an animation can be cancelled.\n */\nonEnd) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n            onEnd && onEnd();\n        },\n        onStop: onEnd,\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\nexport { animateMotionValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}