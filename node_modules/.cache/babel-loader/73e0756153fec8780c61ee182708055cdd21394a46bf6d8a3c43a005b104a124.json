{"ast":null,"code":"import _objectSpread from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _toConsumableArray from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar _excluded = [\"transition\", \"transitionEnd\"];\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nvar reversePriorityOrder = _toConsumableArray(variantPriorityOrder).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n  return function (animations) {\n    return Promise.all(animations.map(function (_ref) {\n      var animation = _ref.animation,\n        options = _ref.options;\n      return animateVisualElement(visualElement, animation, options);\n    }));\n  };\n}\nfunction createAnimationState(visualElement) {\n  var animate = animateList(visualElement);\n  var state = createState();\n  var isInitialRender = true;\n  /**\n   * This function will be used to reduce the animation definitions for\n   * each active animation type into an object of resolved values for it.\n   */\n  var buildResolvedTypeValues = function buildResolvedTypeValues(type) {\n    return function (acc, definition) {\n      var _a;\n      var resolved = resolveVariant(visualElement, definition, type === \"exit\" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);\n      if (resolved) {\n        var transition = resolved.transition,\n          transitionEnd = resolved.transitionEnd,\n          target = _objectWithoutProperties(resolved, _excluded);\n        acc = _objectSpread(_objectSpread(_objectSpread({}, acc), target), transitionEnd);\n      }\n      return acc;\n    };\n  };\n  /**\n   * This just allows us to inject mocked animation functions\n   * @internal\n   */\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\n   * When we receive new props, we need to:\n   * 1. Create a list of protected keys for each type. This is a directory of\n   *    value keys that are currently being \"handled\" by types of a higher priority\n   *    so that whenever an animation is played of a given type, these values are\n   *    protected from being animated.\n   * 2. Determine if an animation type needs animating.\n   * 3. Determine if any values have been removed from a type and figure out\n   *    what to animate those to.\n   */\n  function animateChanges(changedActiveType) {\n    var props = visualElement.getProps();\n    var context = visualElement.getVariantContext(true) || {};\n    /**\n     * A list of animations that we'll build into as we iterate through the animation\n     * types. This will get executed at the end of the function.\n     */\n    var animations = [];\n    /**\n     * Keep track of which values have been removed. Then, as we hit lower priority\n     * animation types, we can check if they contain removed values and animate to that.\n     */\n    var removedKeys = new Set();\n    /**\n     * A dictionary of all encountered keys. This is an object to let us build into and\n     * copy it without iteration. Each time we hit an animation type we set its protected\n     * keys - the keys its not allowed to animate - to the latest version of this object.\n     */\n    var encounteredKeys = {};\n    /**\n     * If a variant has been removed at a given index, and this component is controlling\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\n     */\n    var removedVariantIndex = Infinity;\n    /**\n     * Iterate through all animation types in reverse priority order. For each, we want to\n     * detect which values it's handling and whether or not they've changed (and therefore\n     * need to be animated). If any values have been removed, we want to detect those in\n     * lower priority props and flag for animation.\n     */\n    var _loop = function _loop() {\n      var type = reversePriorityOrder[i];\n      var typeState = state[type];\n      var prop = props[type] !== undefined ? props[type] : context[type];\n      var propIsVariant = isVariantLabel(prop);\n      /**\n       * If this type has *just* changed isActive status, set activeDelta\n       * to that status. Otherwise set to null.\n       */\n      var activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\n       * If this prop is an inherited variant, rather than been set directly on the\n       * component itself, we want to make sure we allow the parent to trigger animations.\n       *\n       * TODO: Can probably change this to a !isControllingVariants check\n       */\n      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\n       *\n       */\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\n       * Set all encountered keys so far as the protected keys for this type. This will\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n       */\n      typeState.protectedKeys = _objectSpread({}, encounteredKeys);\n      // Check if we can skip analysing this prop early\n      if (\n      // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null ||\n      // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp ||\n      // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        return \"continue\";\n      }\n      /**\n       * As we go look through the values defined on this type, if we detect\n       * a changed value or a value that was removed in a higher priority, we set\n       * this to true and add this prop to the animation list.\n       */\n      var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      var shouldAnimateType = variantDidChange ||\n      // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||\n      // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      var handledRemovedValues = false;\n      /**\n       * As animations can be set as variant lists, variants or target objects, we\n       * coerce everything to an array if it isn't one already\n       */\n      var definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\n       * Build an object of all the resolved values. We'll use this in the subsequent\n       * animateChanges calls to determine whether a value has changed.\n       */\n      var resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\n       * Now we need to loop through all the keys in the prev prop and this prop,\n       * and decide:\n       * 1. If the value has changed, and needs animating\n       * 2. If it has been removed, and needs adding to the removedKeys set\n       * 3. If it has been removed in a higher priority type and needs animating\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n       *    needs adding to the type's protectedKeys list.\n       */\n      var _typeState$prevResolv = typeState.prevResolvedValues,\n        prevResolvedValues = _typeState$prevResolv === void 0 ? {} : _typeState$prevResolv;\n      var allKeys = _objectSpread(_objectSpread({}, prevResolvedValues), resolvedValues);\n      var markToAnimate = function markToAnimate(key) {\n        shouldAnimateType = true;\n        if (removedKeys.has(key)) {\n          handledRemovedValues = true;\n          removedKeys.delete(key);\n        }\n        typeState.needsAnimating[key] = true;\n        var motionValue = visualElement.getValue(key);\n        if (motionValue) motionValue.liveStyle = false;\n      };\n      for (var key in allKeys) {\n        var next = resolvedValues[key];\n        var prev = prevResolvedValues[key];\n        // If we've already handled this we can just skip ahead\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\n         * If the value has changed, we probably want to animate it.\n         */\n        var valueHasChanged = false;\n        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n          valueHasChanged = !shallowCompare(next, prev);\n        } else {\n          valueHasChanged = next !== prev;\n        }\n        if (valueHasChanged) {\n          if (next !== undefined && next !== null) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\n           * If next hasn't changed and it isn't undefined, we want to check if it's\n           * been removed by a higher priority\n           */\n          markToAnimate(key);\n        } else {\n          /**\n           * If it hasn't changed, we add it to the list of protected values\n           * to ensure it doesn't get animated.\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\n       * Update the typeState so next time animateChanges is called we can compare the\n       * latest prop and resolvedValues to these.\n       */\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\n       *\n       */\n      if (typeState.isActive) {\n        encounteredKeys = _objectSpread(_objectSpread({}, encounteredKeys), resolvedValues);\n      }\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\n       * If this is an inherited prop we want to hard-block animations\n       */\n      if (shouldAnimateType && (!isInherited || handledRemovedValues)) {\n        animations.push.apply(animations, _toConsumableArray(definitionList.map(function (animation) {\n          return {\n            animation: animation,\n            options: {\n              type: type\n            }\n          };\n        })));\n      }\n    };\n    for (var i = 0; i < numAnimationTypes; i++) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n    }\n    /**\n     * If there are some removed value that haven't been dealt with,\n     * we need to create a new animation that falls back either to the value\n     * defined in the style prop, or the last read value.\n     */\n    if (removedKeys.size) {\n      var fallbackAnimation = {};\n      removedKeys.forEach(function (key) {\n        var fallbackTarget = visualElement.getBaseTarget(key);\n        var motionValue = visualElement.getValue(key);\n        if (motionValue) motionValue.liveStyle = true;\n        // @ts-expect-error - @mattgperry to figure if we should do something here\n        fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n      });\n      animations.push({\n        animation: fallbackAnimation\n      });\n    }\n    var shouldAnimate = Boolean(animations.length);\n    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\n   * Change whether a certain animation type is active.\n   */\n  function setActive(type, isActive) {\n    var _a;\n    // If the active state hasn't changed, we can safely do nothing here\n    if (state[type].isActive === isActive) return Promise.resolve();\n    // Propagate active change to children\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      var _a;\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    var animations = animateChanges(type);\n    for (var key in state) {\n      state[key].protectedKeys = {};\n    }\n    return animations;\n  }\n  return {\n    animateChanges: animateChanges,\n    setActive: setActive,\n    setAnimateFunction: setAnimateFunction,\n    getState: function getState() {\n      return state;\n    },\n    reset: function reset() {\n      state = createState();\n      isInitialRender = true;\n    }\n  };\n}\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState() {\n  var isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return {\n    isActive: isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  return {\n    animate: createTypeState(true),\n    whileInView: createTypeState(),\n    whileHover: createTypeState(),\n    whileTap: createTypeState(),\n    whileDrag: createTypeState(),\n    whileFocus: createTypeState(),\n    exit: createTypeState()\n  };\n}\nexport { checkVariantsDidChange, createAnimationState };","map":{"version":3,"names":["isAnimationControls","isKeyframesTarget","shallowCompare","isVariantLabel","resolveVariant","variantPriorityOrder","animateVisualElement","reversePriorityOrder","_toConsumableArray","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","_ref","animation","options","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","type","acc","definition","_a","resolved","presenceContext","custom","undefined","transition","transitionEnd","target","_objectWithoutProperties","_excluded","_objectSpread","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","getProps","context","getVariantContext","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","_loop","i","typeState","prop","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","Array","isArray","resolvedValues","reduce","_typeState$prevResolv","prevResolvedValues","allKeys","markToAnimate","key","has","delete","needsAnimating","motionValue","getValue","liveStyle","next","prev","hasOwnProperty","valueHasChanged","add","blockInitialAnimation","push","apply","_ret","size","fallbackAnimation","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","initial","resolve","setActive","variantChildren","child","animationState","getState","reset","createTypeState","arguments","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit"],"sources":["/Users/Ksquare/Documents/Software/home/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"sourcesContent":["import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        var _a;\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const props = visualElement.getProps();\n        const context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             */\n            if (shouldAnimateType && (!isInherited || handledRemovedValues)) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}