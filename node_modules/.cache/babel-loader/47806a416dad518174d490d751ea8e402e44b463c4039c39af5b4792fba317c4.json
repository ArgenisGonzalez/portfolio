{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/Ksquare/Documents/Software/home/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\", \"as\", \"axis\", \"onReorder\", \"values\"];\nimport { jsx } from 'react/jsx-runtime';\nimport { invariant } from '../../utils/errors.mjs';\nimport { forwardRef, useRef, useEffect } from 'react';\nimport { ReorderContext } from '../../context/ReorderContext.mjs';\nimport { motion } from '../../render/components/motion/proxy.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { checkReorder } from './utils/check-reorder.mjs';\nfunction ReorderGroupComponent(_ref, externalRef) {\n  var children = _ref.children,\n    _ref$as = _ref.as,\n    as = _ref$as === void 0 ? \"ul\" : _ref$as,\n    _ref$axis = _ref.axis,\n    axis = _ref$axis === void 0 ? \"y\" : _ref$axis,\n    onReorder = _ref.onReorder,\n    values = _ref.values,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var Component = useConstant(function () {\n    return motion[as];\n  });\n  var order = [];\n  var isReordering = useRef(false);\n  invariant(Boolean(values), \"Reorder.Group must be provided a values prop\");\n  var context = {\n    axis: axis,\n    registerItem: function registerItem(value, layout) {\n      // If the entry was already added, update it rather than adding it again\n      var idx = order.findIndex(function (entry) {\n        return value === entry.value;\n      });\n      if (idx !== -1) {\n        order[idx].layout = layout[axis];\n      } else {\n        order.push({\n          value: value,\n          layout: layout[axis]\n        });\n      }\n      order.sort(compareMin);\n    },\n    updateOrder: function updateOrder(item, offset, velocity) {\n      if (isReordering.current) return;\n      var newOrder = checkReorder(order, item, offset, velocity);\n      if (order !== newOrder) {\n        isReordering.current = true;\n        onReorder(newOrder.map(getValue).filter(function (value) {\n          return values.indexOf(value) !== -1;\n        }));\n      }\n    }\n  };\n  useEffect(function () {\n    isReordering.current = false;\n  });\n  return jsx(Component, _objectSpread(_objectSpread({}, props), {}, {\n    ref: externalRef,\n    ignoreStrict: true,\n    children: jsx(ReorderContext.Provider, {\n      value: context,\n      children: children\n    })\n  }));\n}\nvar ReorderGroup = /*@__PURE__*/forwardRef(ReorderGroupComponent);\nfunction getValue(item) {\n  return item.value;\n}\nfunction compareMin(a, b) {\n  return a.layout.min - b.layout.min;\n}\nexport { ReorderGroup, ReorderGroupComponent };","map":{"version":3,"names":["_objectSpread","_objectWithoutProperties","_excluded","jsx","invariant","forwardRef","useRef","useEffect","ReorderContext","motion","useConstant","checkReorder","ReorderGroupComponent","_ref","externalRef","children","_ref$as","as","_ref$axis","axis","onReorder","values","props","Component","order","isReordering","Boolean","context","registerItem","value","layout","idx","findIndex","entry","push","sort","compareMin","updateOrder","item","offset","velocity","current","newOrder","map","getValue","filter","indexOf","ref","ignoreStrict","Provider","ReorderGroup","a","b","min"],"sources":["/Users/Ksquare/Documents/Software/home/node_modules/framer-motion/dist/es/components/Reorder/Group.mjs"],"sourcesContent":["\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { invariant } from '../../utils/errors.mjs';\nimport { forwardRef, useRef, useEffect } from 'react';\nimport { ReorderContext } from '../../context/ReorderContext.mjs';\nimport { motion } from '../../render/components/motion/proxy.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { checkReorder } from './utils/check-reorder.mjs';\n\nfunction ReorderGroupComponent({ children, as = \"ul\", axis = \"y\", onReorder, values, ...props }, externalRef) {\n    const Component = useConstant(() => motion[as]);\n    const order = [];\n    const isReordering = useRef(false);\n    invariant(Boolean(values), \"Reorder.Group must be provided a values prop\");\n    const context = {\n        axis,\n        registerItem: (value, layout) => {\n            // If the entry was already added, update it rather than adding it again\n            const idx = order.findIndex((entry) => value === entry.value);\n            if (idx !== -1) {\n                order[idx].layout = layout[axis];\n            }\n            else {\n                order.push({ value: value, layout: layout[axis] });\n            }\n            order.sort(compareMin);\n        },\n        updateOrder: (item, offset, velocity) => {\n            if (isReordering.current)\n                return;\n            const newOrder = checkReorder(order, item, offset, velocity);\n            if (order !== newOrder) {\n                isReordering.current = true;\n                onReorder(newOrder\n                    .map(getValue)\n                    .filter((value) => values.indexOf(value) !== -1));\n            }\n        },\n    };\n    useEffect(() => {\n        isReordering.current = false;\n    });\n    return (jsx(Component, { ...props, ref: externalRef, ignoreStrict: true, children: jsx(ReorderContext.Provider, { value: context, children: children }) }));\n}\nconst ReorderGroup = /*@__PURE__*/ forwardRef(ReorderGroupComponent);\nfunction getValue(item) {\n    return item.value;\n}\nfunction compareMin(a, b) {\n    return a.layout.min - b.layout.min;\n}\n\nexport { ReorderGroup, ReorderGroupComponent };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}